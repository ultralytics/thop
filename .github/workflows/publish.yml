# Ultralytics YOLO 🚀, AGPL-3.0 license
# Publish pip package to PyPI https://pypi.org/

name: Publish to PyPI

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      pypi:
        type: boolean
        description: Publish to PyPI

jobs:
  publish:
    name: Publish
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          pip install toml requests

      - name: Determine Project Version
        id: determine_version
        shell: python
        run: |
          import os
          import toml

          # Load the pyproject.toml
          pyproject = toml.load('pyproject.toml')
          project_version = pyproject['project'].get('version', 'dynamic')

          if project_version == 'dynamic':
              # If the version is dynamic, retrieve it from the specified file
              dynamic_version_info = pyproject['tool']['setuptools']['dynamic']['version']
              version_attr = dynamic_version_info['attr']

              # Extract the module path and attribute name
              module_path = version_attr.split('.')[0].replace('.', '/')
              attr_name = version_attr.split('.')[-1]

              # Assume the version is in __init__.py if it's a package (directory with __init__.py)
              init_file_path = os.path.join(module_path, "__init__.py")

              # Read the __init__.py file and extract the version
              with open(init_file_path) as f:
                  for line in f:
                      if line.startswith(attr_name):
                          local_version = line.split('=')[1].strip().strip("'\"")
                          break
              print(f"Dynamic version detected. Local Version: {local_version}")
          else:
              # If the version is static, use it directly
              local_version = project_version
              print(f"Static version detected. Local Version: {local_version}")

          # Set the local version as an environment variable
          with open(os.getenv('GITHUB_ENV'), 'a') as env_file:
              env_file.write(f"LOCAL_VERSION={local_version}\n")

      - name: Check version increments
        id: version_check
        run: |
          import os
          import requests
          from packaging import version

          # Get the local version from the environment variable
          local_version = os.getenv('LOCAL_VERSION')
          print(f"Local Version: {local_version}")

          # Load package name from pyproject.toml
          import toml
          pyproject = toml.load('pyproject.toml')
          package_name = pyproject['project']['name']

          # Get the online package version from PyPI using the API
          response = requests.get(f"https://pypi.org/pypi/{package_name}/json")
          if response.status_code == 200:
              online_version = response.json()['info']['version']
              print(f"Online Version: {online_version}")

              # Parse versions
              local_ver = version.parse(local_version)
              online_ver = version.parse(online_version)

              # Determine if we should publish
              publish = False

              if local_ver.major == online_ver.major:
                  if local_ver.minor == online_ver.minor:
                      if 0 < (local_ver.micro - online_ver.micro) <= 2:
                          publish = True
                          print('Patch version has increased by 1 or 2. Ready to publish ✅.')
                  elif (local_ver.minor - online_ver.minor) == 1 and local_ver.micro == 0:
                      publish = True
                      print('Minor version has increased by 1 and patch version reset. Ready to publish ✅.')
              elif (local_ver.major - online_ver.major) == 1 and local_ver.minor == 0 and local_ver.micro == 0:
                  publish = True
                  print('Major version has increased by 1 and minor/patch versions reset. Ready to publish ✅.')
          else:
              print("Package not found on PyPI, assuming this is the first release. Ready to publish ✅.")
              publish = True

          if publish:
              print("Local version is higher than PyPI version. Publishing new version to PyPI ✅.")
              with open(os.getenv('GITHUB_ENV'), 'a') as env_file:
                  env_file.write(f'PUBLISH=true\n')
                  env_file.write(f'NEW_VERSION={local_version}\n')
          else:
              print("No significant version increment, skipping publish ❌.")
              with open(os.getenv('GITHUB_ENV'), 'a') as env_file:
                  env_file.write(f'PUBLISH=false\n')

      - name: Generate Release Notes
        if: env.PUBLISH == 'true'
        shell: python
        run: |
          import os
          import subprocess

          # Get the previous tag
          previous_tag = subprocess.check_output(["git", "describe", "--tags", "--abbrev=0"]).strip().decode('utf-8')
          print(f"Previous tag: {previous_tag}")

          # Generate release notes based on commits since the last tag
          release_notes = subprocess.check_output(["git", "log", f"{previous_tag}..HEAD", "--pretty=format:* %s"]).decode('utf-8')
          print("Release Notes:")
          print(release_notes)

          # Export the release notes as an environment variable
          with open(os.getenv('GITHUB_ENV'), 'a') as env_file:
              env_file.write(f"RELEASE_NOTES<<EOF\n{release_notes}\nEOF\n")

      - name: Create a new tag
        if: env.PUBLISH == 'true' && github.event.inputs.pypi == 'true'
        run: |
          git config --global user.name "UltralyticsAssistant"
          git config --global user.email "web@ultralytics.com"
          git tag -a v${{ env.NEW_VERSION }} -m "Release version ${{ env.NEW_VERSION }}"
          git push origin v${{ env.NEW_VERSION }}
          echo "Created and pushed tag v${{ env.NEW_VERSION }} 🏷️."

      - name: Create GitHub Release
        if: env.PUBLISH == 'true' && github.event.inputs.pypi == 'true'
        uses: actions/create-release@v1
        with:
          tag_name: v${{ env.NEW_VERSION }}
          release_name: "Release v${{ env.NEW_VERSION }}"
          body: ${{ env.RELEASE_NOTES }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish to PyPI
        if: env.PUBLISH == 'true' && github.event.inputs.pypi == 'true'
        run: |
          pip install --upgrade pip build twine
          python -m build
          python -m twine upload dist/* --non-interactive -u __token__ -p ${{ secrets.PYPI_TOKEN }}
          echo "Published version v${{ env.NEW_VERSION }} to PyPI 📦."
